# 20191216(월) REPORT

- 라이브러리 로드 및 데이터 불러오기

  ```python
  import pandas as pd
  import numpy as np
  import warnings
  from ast import literal_eval
  
  movies = pd.read_csv('./input/tmdb_5000_movies.csv')
  ```

  

- 데이터 가공하기

  ```python
  movies_df = movies[['id', 'title', 'genres', 'vote_average', 'vote_count', 'popularity', 'keywords', 'overview']]
  movies_df['genres'] = movies_df['genres'].apply(literal_eval)
  movies_df['keywords'] = movies_df['keywords'].apply(literal_eval)
  ```

  

## 장르 컨텐츠 유사도 측정

만약 영화 A의 장르가 `[Action, Adventure, Fantasy, Science Fiction]`이고,
B가 `[Adventure, Fantasy, Action]`으로 되어있다면 어떻게 장르별 유사도를 측정할까?

여러가지 방법이 있을 수 있으나, 가장 간단한 방법은 genres를 문자열로 변경한 뒤, 이를 CountVectorizer로 피처 벡터화한 행렬 데이터 값을 코사인 유사도로 비교하는 것입니다.
genres 컬럼을 기반으로 하는 컨텐츠 기반 필터링은 다음 단계로 구현하겠습니다.

1. 문자열로 변환된 genres 컬럼을 Count 기반으로 피처 벡터화 변환합니다.
2. genres 문자열을 피처 벡터화 행렬로 변환한 데이터 셋을 코사인 유사도를 통해 비교합니다. 이를 위해 데이터 셋의 레코드별로 타 레코드와 장르에서 코사인 유사도 값을 가지는 객체를 생성합니다.
3. 장르 유사도가 높은 영화 중에서 평점이 높은 순으로 영화를 추천합니다.

장르 컬럼을 문자열로 변환한 뒤, 사이킷런의 CountVectorizer를 이용해 피처 벡터 행렬로 만들겠습니다.



```python
from sklearn.feature_extraction.text import CountVectorizer

# CountVectorizer를 적용하기 위해 공백문자로 word 단위가 구분되는 문자열로 변환.

movies_df['genres_literal'] = movies_df['genres'].apply(lambda x: (' ').join(x))
count_vect = CountVectorizer(min_df=0, ngram_range=(1,2))
genre_mat = count_vect.fit_transform(movies_df['genres_literal'])
```



CountVectorizer로 변환해 4803개의 레코드와 276개의 개별 단어 피처로 구성된 피처 벡터 행렬을 만듬.
이렇게 생성된 행렬에 사이킷런의 cosine_similarity()를 이용해 코사인 유사도를 계산하겠습니다.



```python
from sklearn.metrics.pairwise import cosine_similarity

genre_sim = cosine_similarity(genre_mat, genre_mat)
```

cosine_similarities() 호출로 생성된 genre_sim 객체는 movies_df 의 genre_literal 컬럼을 피처 벡터화한 행럴(genre_mat) 데이터의 행별로 유사도 정보를 가지고 있으며, 결국은 movies_df DataFrame의 행별 장르 유사도 값을 가지고 있는 것입니다. movies_df를 장르 기준으로 컨텐츠 기반 필터링을 수행하려면 movies_df의 개별 레코드에 대해서 가장 장르 유사도가 높은 순으로 다른 레코드를 추출해야 하는데, 이를 위해 앞에서 생성한 genre_sim 객체를 이용합니다.

genre_sim 객체의 기준 행별로 비교 대상이 되는 행의 유사도 값이 높은 순으로 정렬된 행렬의 위치 인덱스 값을 추출하면 됩니다. 값이 높은 순으로 정렬도니 비교 대상 행의 유사도 값이 아니라 비교 대상 행의 위치 인덱스임에 주의합시다. numpydml argsort() 함수를 이용하여 argsort()[:, ::1](vscode-resource://file///c%3A/Users/student/.vscode/extensions/ms-python.python-2019.11.50794/out/datascience-ui/native-editor/) 을 이용하면 유사도가 높은 순으로 정리된 genre_sim 객체의 배교 행 위치 인덱스 값을 간편하게 얻을 수 있습니다. genre_sim.argsort()[:, ::1](vscode-resource://file///c%3A/Users/student/.vscode/extensions/ms-python.python-2019.11.50794/out/datascience-ui/native-editor/) 을 사용해 높은 순으로 정렬된 비교 행 위치 인덱스 값을 가져오고 그 중에 0번 레코드의 비교 행 위치 인덱스 값만 샘플로 추출해 보겠습니다.

```python
genre_sim_sorted_ind = genre_sim.argsort()[:, ::-1]
```



## 장르 컨텐츠 필터링을 이용한 영화추천

```python
def find_sim_movie(df, sorted_ind, title_name, top_n = 10):

    # 인자로 입력된 movies_df 데이터프레임에서 'title' 컬럼이 입력된 title_name 값인 데이터프레임을 추출
    title_movie = df[df['title'] == title_name]


    # title_named을 가진 데이터프레임의 index 객체를 ndarray로 변환하고
    # sorted_ind 인자로 입력된 genre_sim_sorted_ind 객체에서 유사도 순으로 top_n 개의 index 추출
    title_index = title_movie.index.values
    similar_indexes = sorted_ind[title_index, :(top_n)]

    # 추출된 top_n index 출력. top_n index 는 2차원 데이터임.
    # 데이터프레임에서 index로 사용하기 위해서 1차원 array 로 변경.

    print(similar_indexes)
    similar_indexes = similar_indexes.reshape(-1)
    
    return df.iloc[similar_indexes]
```

```python
# 위 함수를 이용해 영화 '대부'와 장르별로 유사한 영화 10개를 추천해보겠습니다.

similar_movies = find_sim_movie(movies_df, genre_sim_sorted_ind, 'The Godfather', 10)
similar_movies[['title', 'vote_average']]
```

대부 2 추천으로 봐서 잘된것도 같지만, Light Sleeper 같이 이상한 영화도 추천함. 좀 더 개선이 필요함을 알 수 있음.
게다가 Mi America의 경우 평점이 0점임을 알 수 있음.
이번에는 일단 좀 더 많은 후보군을 선정한 뒤 영화의 평점에 따라 필터링해서 최종 추천하는 방식으로 변경하겠습니다.
영화의 평점 정보인 'vote_average' 값을 이용하겠습니다.
그런데 1명, 2명의 소수 관객이 특정 영화에 만점이나 매우 높은 평점을 부여해 왜곡된 데이터가 발생할 수 있습니다. 이를 확인하기 위해 오름차순으로 정렬해 확인해 보겠습니다.



앞서 말했듯이 왜곡된 데이터가 존재함을 확인할 수 있습니다.
이를 회피하기 위해 새로운 평가방식이 필요.
평가횟수에 대한 가중치가 부여된 평점(Weighted Rating) 방식을 사용하겠습니다.

가중 평점 = $\frac{v}{(v+m)}$ * R + $\frac{m}{(v+m)}$ * C

각 변수의 의미

- v: 개별 영화에 평점을 투표한 횟수, movies_df의 'vote_count'값
- m: 평점을 부여하기 위한최수 투표 횟수, 가중치를 직접 조절하는 역할을 하는데, m 값을 높이면 평점 투표횟수가 많은 영화에 더 많은 가중 평점을 부여, m 값은 전체 투표 횟수에서 상위 60% 에 해당하는 횟수를 기준으로 정하겠습니다.
- R: 개별 영화에 대한 평균 평점, 'vote_average'
- C: 전체 영화에 대한 평균 평점 'movies_df['vote_average'].mean()'

